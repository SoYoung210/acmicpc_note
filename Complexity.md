# 시공간 복잡도
## 시간복잡도
### 1. 이론

Time Complexity : 수행시간 분석결과. <br>
시간 복잡도는 연산의 횟수를 세고, 처리해야 할 데이터 수 n에 대한 연산횟수의 함수 T(n)을 고려하면 된다. <br>
        ```
        T(n)= Number of operations
        ```
        <br>
다음과 같은 코드가 있다고 가정하자. <br>
사용자로부터 숫자를 입력받고 arr 배열에서 해당 숫자를 찾는 코드이다.

```c
#include <stdio.h>

int main(void) {
  int arr[] = {1,2,3,4,5};
  int i;
  int n;
  scanf("%d",&n);
  
  for(i = 0; i<5; i++) {
    if(arr[i] == n)
      break;
  }
  return 0;
}
```

이러한 순차 탐색 알고리즘의 핵심은 ‘얼마나 빨리 원하는 값을 찾는가’ 이다. <br>
Best Case인 경우 1번만에 종료되지만, Worst Case인 경우 n(배열의 크기)번 만에 종료된다. <br>
따라서 최악의 경우 T(n)은 다음과 같다. <br>
```
T(n)= n
```




연산횟수에 대한 함수를 살펴 보았으니, 흔히 시간 복잡도를 계산할 때 표현하는 
```
O(n)
```
이른바 ‘빅 오’ 표기법에 대해 알아보자. <br>
먼저 연산횟수 함수 T(n) 에서 O(n)을 계산한 예제들을 살펴보자. <br>
 
Big O 는 T(n)으로 표현한 함수의 최고차항의 차수이다. 계수나 최고차항이 아닌 부분은 고려하지 않는다.  <br>
Big O의 순서는 아래와 같고, n^2이상일 경우 input case가 몇 가지 인지 고려해봐야 한다. <br>
  (수행시간이 1second 등으로 제한이 있을 경우, 시간 내에 탐색이 종료되지 않을 수 있다.) <br>
 
(주: 경험적인 부분이지만, n^2는 대략 Input이 1000개 정도가 한계이다.) <br>

### 1.2 sort별 시간 복잡도
	bubble
 
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(N^2)
	최선 시간 복잡도 : O(N^2)

	insert
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(N^2)
	최선 시간 복잡도 : O(N^2)
	select
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(N^2)
	최선 시간 복잡도 : O(N^2)
	heap
 
	최악 시간 복잡도 : O(NlogN)
	평균 시간 복잡도 : O(NlogN)
	최선 시간 복잡도 : O(NlogN)
	quick
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(NlogN)
	최선 시간 복잡도 : O(NlogN)
	merge

	최악 시간 복잡도 : O(NlogN)
	평균 시간 복잡도 : O(NlogN)
	최선 시간 복잡도 : O(NlogN)
	sleep
 
	시간 복잡도 : O(Max(V))
