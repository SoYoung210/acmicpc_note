# 시공간 복잡도
## 시간복잡도
### 1. 이론

Time Complexity : 수행시간 분석결과. <br>
시간 복잡도는 연산의 횟수를 세고, 처리해야 할 데이터 수 n에 대한 연산횟수의 함수 T(n)을 고려하면 된다. <br>
        ```
        T(n)= Number of operations
        ```
        <br>
다음과 같은 코드가 있다고 가정하자. <br>
사용자로부터 숫자를 입력받고 arr 배열에서 해당 숫자를 찾는 코드이다.

```c
#include <stdio.h>

int main(void) {
  int arr[] = {1,2,3,4,5};
  int i;
  int n;
  scanf("%d",&n);
  
  for(i = 0; i<5; i++) {
    if(arr[i] == n)
      break;
  }
  return 0;
}
```

이러한 순차 탐색 알고리즘의 핵심은 ‘얼마나 빨리 원하는 값을 찾는가’ 이다. <br>
Best Case인 경우 1번만에 종료되지만, Worst Case인 경우 n(배열의 크기)번 만에 종료된다. <br>
따라서 최악의 경우 T(n)은 다음과 같다. <br>
```
T(n)= n
```




연산횟수에 대한 함수를 살펴 보았으니, 흔히 시간 복잡도를 계산할 때 표현하는 
```
O(n)
```
이른바 ‘빅 오’ 표기법에 대해 알아보자. <br>
먼저 연산횟수 함수 T(n) 에서 O(n)을 계산한 예제들을 살펴보자. <br>
 
Big O 는 T(n)으로 표현한 함수의 최고차항의 차수이다. 계수나 최고차항이 아닌 부분은 고려하지 않는다.  <br>
Big O의 순서는 아래와 같고, n^2이상일 경우 input case가 몇 가지 인지 고려해봐야 한다. <br>
  (수행시간이 1second 등으로 제한이 있을 경우, 시간 내에 탐색이 종료되지 않을 수 있다.) <br>
 
(주: 경험적인 부분이지만, n^2는 대략 Input이 1000개 정도가 한계이다.) <br>

### 1.2 sort별 시간 복잡도
	bubble
 
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(N^2)
	최선 시간 복잡도 : O(N^2)

	insert
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(N^2)
	최선 시간 복잡도 : O(N^2)
	select
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(N^2)
	최선 시간 복잡도 : O(N^2)
	heap
 
	최악 시간 복잡도 : O(NlogN)
	평균 시간 복잡도 : O(NlogN)
	최선 시간 복잡도 : O(NlogN)
	quick
 
	최악 시간 복잡도 : O(N^2)
	평균 시간 복잡도 : O(NlogN)
	최선 시간 복잡도 : O(NlogN)
	merge

	최악 시간 복잡도 : O(NlogN)
	평균 시간 복잡도 : O(NlogN)
	최선 시간 복잡도 : O(NlogN)
	sleep
 
	시간 복잡도 : O(Max(V))

## 공간 복잡도
### 1.1 이론
알고리즘의 공간 복잡도는 알고리즘 실행에 필요한 메모리 공간이 얼마나 많은지를 의미한다. <br>
(알고리즘이 필요로 하는 필수 고정 공간 – 상수나 변수의 크기 + 동적 메모리 할당이나 재귀 스택 공간) <br>
알고리즘에 의해 필요한 공간은 다음 두 가지 요인의 합으로 표현한다. <br>
```
S(P)= C+SP(I)
```
여기서 C 는 고정 부분이고, S(I)가 가변 부분이다. I는 인스턴스의 특징을 의미한다. <br>
예제로 좀 더 살펴보자. <br>
### 1.2 예제
#### 공간 복잡도 예제 1
```c
float abc(float a, float b, float c)

{

     return(a + b + b*c + (a + b - c)/(a + b) + 4.0);

}
//공간 복잡도 = 0.
```
변수 a, b, c는 parameter로, 함수 abc내에서 해결하고자 하는 문제와는 무관하므로 공간 복잡도는 0이다.  
  
#### 공간 복잡도 예제 2  
```c
float Sum(float a[], int n)

{

     float s = 0.0;

     for(int i = 1; i < = n; i++)

          s += a[i];

     return s;

}
//공간 복잡도 = n+3
```
위 함수에서 사용되는 변수는 a[] , n, s, I 이다. 이번에도 a[]와 n은 인자로 전달 된다.  
1번 예제와는 다르게 n개의 원소 모두 참조되고 있다. 따라서 공간 복잡도는 n+3 이 된다.  
(a[] 공간과 변수 n, s, I 를 위한 공간)  
  
#### 공간 복잡도 예제 3  
```c
float RSum(float a[], int n)

{

     if(n <= 0)

          return (0.0);

     else

          return (RSum(a, n-1) + a[n]);

}
//공간 복잡도 = 3(n+1)
```
우선 recursion으로 구현되어 있음을 알 수 있다. <br> 위의 경우 살펴볼 변수는 a[], n이다. 우선 변수 n은 if-문 내에서 순환의 한계값으로 사용되고 있음을 볼 수 있다. <br> 또한, 변수 a[]는 합을 구하기 위하여 사용되고 있으며 a[]의 원소 중에서 n번째의 원소만 필요로 한다. 따라서 변수 a[]와 n이 모두 알고리즘과 밀접한 관계가 있으므로, 프로그램이 필요로 하는 공간은 (a[]의 n번째 원소를 의한 공간) + (n을 위한 공간) = 1 + 1 으로 볼 수 있다. <br> 그러나 위의 프로그램은 **순환기법** 에 의해 작성되었음을 고려해야 한다. 즉, 프로그램이 순환적으로 실행될 것을 고려해서 몇번의 순환후에 실행이 종료되는지(the depth of recursion)를 계산해야 하며, 또한 순환을 위해서 필요한 복귀 주소(return address)를 저장할 공간도 계산해야 한다. <br> 그러므로 프로그램의 공간 복잡도는 (depth of recursion)×(a[n], n, 복귀 주소를 위한 공간) = (n+1)×3 이 된다.
> [http://qwe1qwe.tistory.com/880](url) 참고하여 작성 하였음.
