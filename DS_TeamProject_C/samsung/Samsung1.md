
# Samsung 구슬 문제 2

## 1. 문제 접근

- 구슬 탈출 하기 전에 몇 가지의 조건을 확인하였다.
- 삼성 문제는 제약 조건으로 정수를 정해진 숫자만 받기 때문에 미리 배열이나 자료형들을 고정된 값으로 선언을 해도 될 것 같다는 생각을 하였습니다.
- 구슬이 움직일 수 있는 방향 4가지
 1. 10번 이상으로 움직이면 -1 출력한다. 
 2. 파란 공과 빨간 공이 겹치지 않는다면 움직이는 만큼 수를 저장한다.
 3. 파란 공이 나오게 되면 -1 출력한다. 
 4. 빨간 공이 나오게 되면 움직인 수를 출력한다. 
 5. 파란 공과 빨간 공의 위치가 겹칠 경우
  - 좌로 이동: x좌표가 컸던 공을 오른쪽으로 한 칸 옮긴다.
  - 우로 이동: x좌표가 작아던 공을 왼쪽으로 한 칸 옮긴다. 
  - 상으로 이동: y좌표가 컸던 공을 아래로 한 칸 옮긴다.
  - 하로 이동: y좌표가 작았던 공을 위로 한 칸 옮긴다.
 6. 방문했던 좌표를 구분하기 한다. 

## 2. 기본적인 알고리즘 

Bfs 완전탐색을 위해서 여러 알고리즘 중에서 bfs를 이용하였다.
그 이유는 이 문제를 방향이 존재하지만 링크 값이 존재하지 않기 때문에 다익스트라를 이용하진 않았다. 
또한 dfs를 이용하지 않은 이유는 깊이 탐색을 하게 될 경우 재귀 함수 호출로 인한 시간 초과가 발생할 것이라고 생각하였다. 
그래서 BFS알고리즘을 선택하였습니다

## 3. 변형되어야 하는 점

1. 포인트 값을 굳이 초기화안 해도 된다.
2. 메인 함수에서 BFS를 실행하기 위해서 따로 메소드로 분리하는 것이 어떠한가?
3. 굳이 Queue_Data로 새로운 자료구조를 만든 이유는 무엇인가?
4. 굳이 객체를 생성할 필요는 없다. 

## 4. 변형 코드 

이 부분은 제가 커밋했던 내용을 바탕으로 소영님의 의견을 받아서 바꾼 내용으로 바꾸면 좋을 것 같아요 

## 5. 유의할 점

둘의 공이 겹쳤을 경우 4가지로 나누어서 옮겨진 공들에 대해서 다시 위치를 조정해야한다는 점이다. 

## 6.  느낀 점

상반기 알고리즘 준비를 할 때에는 전혀 알고리즘과 자료구조를 공부하지 않은 상태로 접하였었다. 하지만 이렇게 트리, 그래프를 통한 개념 이해와 직접 차근차근 구현을 통해 왜 이 알고리즘을 선택하였는지 그리고 다른 알고리즘을 선택하지 않은 이유를 고민하면서 더 성장할 수 있었다. 
